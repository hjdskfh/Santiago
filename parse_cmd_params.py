#!/usr/bin/env python3
"""
Utility to parse parameters from .cmd files generated by run_4_potential.sh

This script can extract all parameters from the simulation command files and
return them as a dictionary for use in other Python scripts.

Usage:
    from parse_cmd_params import parse_cmd_file, find_cmd_files
    
    # Parse a single .cmd file
    params = parse_cmd_file("path/to/simulation.cmd")
    
    # Find and parse all .cmd files in a directory
    all_params = find_cmd_files("runs/run_20250711_123456/")
"""

import re
import os
import glob
from pathlib import Path
from typing import Dict, List, Union, Any, Optional
import argparse
import json


def parse_cmd_file(cmd_file_path: str) -> Dict[str, Any]:
    """
    Parse a .cmd file and extract all parameters from the simulation command.
    
    Args:
        cmd_file_path: Path to the .cmd file
        
    Returns:
        Dictionary containing all parsed parameters
        
    Example:
        >>> params = parse_cmd_file("run.cmd")
        >>> print(params['density'])
        0.5
        >>> print(params['gamma'])
        -0.5
    """
    params = {}
    
    try:
        with open(cmd_file_path, 'r') as f:
            content = f.read()
        
        # Find the actual command line (not the comments)
        lines = content.strip().split('\n')
        command_line = None
        
        for line in lines:
            if line.strip() and not line.strip().startswith('#'):
                command_line = line.strip()
                break
        
        if not command_line:
            raise ValueError(f"No command found in {cmd_file_path}")
        
        # Extract metadata from comments
        metadata = {}
        for line in lines:
            if line.startswith('# Command executed on'):
                metadata['execution_date'] = line.replace('# Command executed on ', '').strip()
            elif line.startswith('# Working directory:'):
                metadata['working_directory'] = line.replace('# Working directory: ', '').strip()
            elif line.startswith('# Git commit:'):
                metadata['git_commit'] = line.replace('# Git commit: ', '').strip()
        
        params['_metadata'] = metadata
        params['_cmd_file'] = cmd_file_path
        params['_full_command'] = command_line
        
        # Parse command line arguments
        # Split the command while preserving quoted arguments
        import shlex
        try:
            args = shlex.split(command_line)
        except ValueError:
            # Fallback for malformed quotes
            args = command_line.split()
        
        # Extract program name
        if args:
            params['_program'] = args[0]
            args = args[1:]  # Remove program name
        
        # Parse --parameter value pairs and --flag arguments
        i = 0
        while i < len(args):
            arg = args[i]
            
            if arg.startswith('--'):
                param_name = arg[2:]  # Remove '--' prefix
                
                # Check if this is a flag (next arg is another --arg or end of list)
                if i + 1 >= len(args) or args[i + 1].startswith('--'):
                    # This is a boolean flag
                    params[param_name] = True
                    i += 1
                else:
                    # This has a value
                    param_value = args[i + 1]
                    
                    # Try to convert to appropriate type
                    converted_value = _convert_value(param_value)
                    params[param_name] = converted_value
                    i += 2
            else:
                # Non-flag argument, skip
                i += 1
        
        return params
        
    except Exception as e:
        raise Exception(f"Error parsing {cmd_file_path}: {str(e)}")


def _convert_value(value_str: str) -> Union[int, float, str]:
    """Convert string value to appropriate type (int, float, or string)."""
    try:
        # Try integer first
        if '.' not in value_str and 'e' not in value_str.lower():
            return int(value_str)
    except ValueError:
        pass
    
    try:
        # Try float
        return float(value_str)
    except ValueError:
        pass
    
    # Keep as string
    return value_str


def find_cmd_files(directory: str, pattern: str = "*.cmd") -> List[str]:
    """
    Find all .cmd files in a directory.
    
    Args:
        directory: Directory to search in
        pattern: File pattern to match (default: "*.cmd")
        
    Returns:
        List of .cmd file paths
    """
    directory = Path(directory)
    return list(map(str, directory.glob(pattern)))


def parse_all_cmd_files(directory: str) -> Dict[str, Dict[str, Any]]:
    """
    Parse all .cmd files in a directory.
    
    Args:
        directory: Directory containing .cmd files
        
    Returns:
        Dictionary mapping cmd file names to their parsed parameters
    """
    cmd_files = find_cmd_files(directory)
    results = {}
    
    for cmd_file in cmd_files:
        try:
            params = parse_cmd_file(cmd_file)
            file_key = Path(cmd_file).stem  # filename without extension
            results[file_key] = params
        except Exception as e:
            print(f"Warning: Failed to parse {cmd_file}: {e}")
            
    return results


def extract_parameter_ranges(all_params: Dict[str, Dict[str, Any]]) -> Dict[str, set]:
    """
    Extract the range of values used for each parameter across all runs.
    
    Args:
        all_params: Dictionary from parse_all_cmd_files()
        
    Returns:
        Dictionary mapping parameter names to sets of unique values
    """
    param_ranges = {}
    
    for run_name, params in all_params.items():
        for param_name, param_value in params.items():
            if param_name.startswith('_'):  # Skip metadata
                continue
                
            if param_name not in param_ranges:
                param_ranges[param_name] = set()
                
            param_ranges[param_name].add(param_value)
    
    return param_ranges


def get_run_by_parameters(all_params: Dict[str, Dict[str, Any]], **filter_params) -> Dict[str, Dict[str, Any]]:
    """
    Filter runs by specific parameter values.
    
    Args:
        all_params: Dictionary from parse_all_cmd_files()
        **filter_params: Parameter name-value pairs to filter by
        
    Returns:
        Dictionary of runs matching the filter criteria
        
    Example:
        >>> matching_runs = get_run_by_parameters(all_params, density=0.5, gamma=-0.5)
    """
    matching_runs = {}
    
    for run_name, params in all_params.items():
        match = True
        for filter_param, filter_value in filter_params.items():
            if params.get(filter_param) != filter_value:
                match = False
                break
        
        if match:
            matching_runs[run_name] = params
            
    return matching_runs


def main():
    """Command line interface for testing the parser."""
    parser = argparse.ArgumentParser(description="Parse parameters from .cmd files")
    parser.add_argument("path", help="Path to .cmd file or directory containing .cmd files")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--ranges", action="store_true", help="Show parameter ranges across all files")
    
    args = parser.parse_args()
    
    if os.path.isfile(args.path):
        # Parse single file
        params = parse_cmd_file(args.path)
        if args.json:
            print(json.dumps(params, indent=2, default=str))
        else:
            print(f"Parameters from {args.path}:")
            for key, value in params.items():
                if not key.startswith('_'):
                    print(f"  {key}: {value}")
    
    elif os.path.isdir(args.path):
        # Parse all files in directory
        all_params = parse_all_cmd_files(args.path)
        
        if args.ranges:
            param_ranges = extract_parameter_ranges(all_params)
            print("Parameter ranges across all runs:")
            for param, values in sorted(param_ranges.items()):
                print(f"  {param}: {sorted(values)}")
        elif args.json:
            print(json.dumps(all_params, indent=2, default=str))
        else:
            print(f"Found {len(all_params)} cmd files in {args.path}")
            for run_name, params in all_params.items():
                print(f"\n{run_name}:")
                for key, value in params.items():
                    if not key.startswith('_'):
                        print(f"  {key}: {value}")
    else:
        print(f"Error: {args.path} is neither a file nor a directory")


if __name__ == "__main__":
    main()
